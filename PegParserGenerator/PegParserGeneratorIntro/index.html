<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    
    <title>vimscriptdev.info - Peg Parser Generator</title>
    <link rel="stylesheet" type="text/css" href="/style.css" media="screen">
    <!-- <link rel="stylesheet" type="text/css" href="/asciidoc.css" media="screen"> -->
    <link rel="stylesheet" type="text/css" href="/syntax.css" media="screen">
    <script type="text/javascript" src="/asciidoc.js"></script>
    <meta name="generator" content="nanoc 3.3.2">
  </head>
  <body>
    <div id="topnav">
        vimscriptdev.info topnav
    </div><!-- topnav -->

    <div id="main">

      <div class="entry">
        <div id="info">
          <h2><a href="/PegParserGenerator/PegParserGeneratorIntro/">Peg Parser Generator</a></h2>
          
          <div class="created_at">2012-04-10 11:34:32 -0700</div>
          
          <div class="tags"><a href="/tag/advanced" rel="tag">advanced</a> <a href="/tag/learn" rel="tag">learn</a> <a href="/tag/vim" rel="tag">vim</a></div>
        </div><!-- info -->
        <div id="content">
          
<!-- begin article -->
<div class="article">
<div id="header">
<h1>Introducing Vimpeg&#8201;&#8212;&#8201;A PEG Parser Generator for Vim</h1>
<span id="author">Barry Arthur</span><br />
<span id="revnumber">version 1.1,</span>
<span id="revdate">October 10, 2011</span>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p><span class="image">
<img src="/PegParserGenerator/vimpeg.png" alt="/PegParserGenerator/vimpeg.png" />
</span></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_vimpeg">What is Vimpeg?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Vimpeg is a Parser Generator which uses the newer Parsing Expression
Grammar formalism to specify the parse rules.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_why_vimpeg">Why Vimpeg?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Vim is a powerful editor. It has lots of features baked right in to
make it an editor most awesome. It has a deliciously potent regular
expression engine, jaw-dropping text-object manipulations, and
fabulous scriptability&#8201;&#8212;&#8201;just to name a few of its aces.</p></div>
<div class="paragraph"><p>One thing our little Vim still lacks, though, is an actual parser.
Regular expressions will only get you so far when you&#8217;re trying to
analyse and understand complex chunks of text. If your text is
inherently infinite or recursive, then regular expressions become at
best combersome, and at worst, useless.</p></div>
<div class="paragraph"><p>So, Vim <strong>needs</strong> a parser. I&#8217;ve needed one myself several times when
wanting to build a new plugin&#8201;&#8212;&#8201;"awesome! This idea will so rock! Now
all I need to do is parse &lt;SomeLanguage&gt; and I&#8217;ll be able to&#8230; awww&#8230;
:-(" I&#8217;ve seen people ask on <tt>#vim</tt>: How can I
&lt;DoSomethingThatNeedsAParser&gt;? And invariable the answer is: You
can&#8217;t.</p></div>
<div class="paragraph"><p>Well&#8230;</p></div>
<div class="paragraph"><p>You <strong>couldn&#8217;t</strong>. Until now. Vimpeg aims to solve this problem.</p></div>
<div class="ulist"><div class="title">What would I use Vimpeg for?</div><ul>
<li>
<p>
You&#8217;ve come to that paralysing sinkhole in your Vimming when you&#8217;ve
  said to youself, "Damn&#8230; I wish Vim had a parser."
</p>
</li>
<li>
<p>
You&#8217;ve asked for something on #vim and the reply is "you can&#8217;t do
  that because Vim doesn&#8217;t have a parser."
</p>
</li>
<li>
<p>
You&#8217;re up to your neck in wrecklessly recursive regexes.
</p>
</li>
</ul></div>
<div class="ulist"><div class="title">Some ideas:</div><ul>
<li>
<p>
An expression calculator (the beginnings of which we explore here.)
</p>
</li>
<li>
<p>
Expanding tokens in typed text (think: snippets, abbrevs, maps.)
</p>
</li>
<li>
<p>
Semantic analysis of code&#8201;&#8212;&#8201;for refactoring, reindenting (but sadly
  not syntax highlighting yet.)
</p>
</li>
<li>
<p>
C Code bifurcation based on #define values&#8201;&#8212;&#8201;want to see what the C
  code would look like with <tt>#define DEBUG</tt> disabled?
</p>
</li>
<li>
<p>
Coffeescript for Vim&#8201;&#8212;&#8201;sugar-coating some of the uglies in VimL&#8201;&#8212;&#8201;  this example will be presented in a subsequent Vimpeg article.
</p>
</li>
</ul></div>
<div class="paragraph"><p>In fact, most of these ideas have been explored in part inside the
<tt>examples/</tt> directory of the <a href="https://github.com/dahu/Vimpeg">Vimpeg</a>
plugin.</p></div>
<div class="paragraph"><p>For the purposes of introducing Vimpeg and parsing in general (if
you&#8217;re new to it), let&#8217;s consider a fairly easy example of reading &amp;
understanding (perhaps calculating) a sum series of integers. They
look like this:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>1 + 2 + 12 + 34</tt></pre>
</div></div>
<div class="paragraph"><p>They can be any (reasonable) length, from a single integer upwards.
So, this is a valid input to our parser:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>123</tt></pre>
</div></div>
<div class="paragraph"><p>As are all of the following:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>1 + 2
3 + 4 + 5
123 + 456 + 789</tt></pre>
</div></div>
<div class="paragraph"><p>Stop. Right now. And think: How would <strong>you</strong> parse such an arbitrarily
long series of integers separated by <tt> + </tt> operators? What tool
would you reach for? What if you <strong>had</strong> to do it in Vim?</p></div>
<div class="paragraph"><p>We&#8217;ll continue to use this example throughout this article and
eventually show you how Vimpeg solves this little parsing requirement.</p></div>
<div class="paragraph"><p>But first, let&#8217;s make sure we&#8217;re all on the same page about the
question: &#8220;What is parsing?&#8221;</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_parsing">Parsing</h2>
<div class="sectionbody">
<div class="paragraph"><p>Feel free to skip to the next section if you&#8217;re comfortable with the
following concepts:</p></div>
<div class="ulist"><ul>
<li>
<p>
parsing
</p>
</li>
<li>
<p>
pasrer generators
</p>
</li>
<li>
<p>
(E)BNF and PEGs
</p>
</li>
</ul></div>
<div class="paragraph"><p>Let&#8217;s begin by defining some terms:</p></div>
<div class="paragraph"><p>(Let&#8217;s all assume we know what <a href="http://www.vim.org">Vim</a> is.)</p></div>
<div class="sect2">
<h3 id="_what_is_em_parsing_em">What is <em>Parsing</em>?</h3>
<div class="paragraph"><p><a href="http://en.wikipedia.org/wiki/Parsing">Parsing</a> is making sense of
something.  When we want a computer to understand something we&#8217;ve
written down for it to do, it needs to <em>parse</em> that writing.  Without
going into too much detail yet, let&#8217;s consider a sentence uttered at
one time or another by your parental unit: "Take the rubbish out!".
When you (eventually&#8201;&#8212;&#8201;after you unplug your iPod, put down your PS3
controller, pocket your smart-phone and wipe the disdain off your
face) parse this sentence, your brain goes through two processes:</p></div>
<div class="ulist"><div class="title">firstly (syntax recognition):</div><ul>
<li>
<p>
it scans the words to make sure they&#8217;re legitimate:
</p>
<div class="ulist"><ul>
<li>
<p>
they&#8217;re in a language you know
</p>
</li>
<li>
<p>
they&#8217;re all valid words, and
</p>
</li>
<li>
<p>
they&#8217;re all in the right order
</p>
</li>
</ul></div>
</li>
</ul></div>
<div class="ulist"><div class="title">and secondly (semantic analysis):</div><ul>
<li>
<p>
it filters out the <em>meaning</em> and presents that to a higher actor
  for further deliberation
</p>
</li>
</ul></div>
<div class="paragraph"><p>In this case, the parser would extract the verb phrase <em>take out</em> and
the noun <em>rubbish</em>. Your higher self (sarcasm aside) <strong>knows</strong> where
this magic <em>out</em> place is. We&#8217;ll come back to these two processes
(<em>syntax recognition</em> and <em>semantic analysis</em>) later.</p></div>
<div class="paragraph"><p>In the case of our sum series of integers, syntax recognition would
involve collecting the sequence of digits that comprise an integer,
skipping unnecessary whitespace and expecting either an end of input
or a <tt>&nbsp;+ </tt> character and another integer and&#8230; so on. If the input
contained an alphabetic character it would fail in this phase&#8201;&#8212;&#8201;alphabetic characters are just not expected in the input. If the
lexical recogniser found two integers separated by whitespace or two
<tt>&nbsp;+ </tt> characters in a row&#8230;  it would <strong>not</strong> fail in this phase&#8201;&#8212;&#8201;these are all valid tokens in <em>this</em> lexical recogniser.</p></div>
<div class="paragraph"><p>TODO: Clean this next paragraph up:</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="/images/icons/note.png" alt="Note" />
</td>
<td class="content">I am describing the more general process of lexical recognition and
it being a seperate stage to semantic analysis which is typical of
most parsers. PEG parsers, however, do not have separate phases as
described here&#8201;&#8212;&#8201;they are quite strict about not only what shape the
next token must have, but also its purpose in this place (context) of
the input. Having two consecutive integers or two consecutive <tt> + </tt>
characters <strong>will</strong> upset a PEG parser expecting a sum series of
integers&#8201;&#8212;&#8201;it&#8217;s just that he gets upset all in his single parse phase&#8201;&#8212;&#8201;he doesn&#8217;t delay his expression of disappointment in not matching
both the desired structure and the desired meaning simultaneously.</td>
</tr></table>
</div>
<div class="paragraph"><p>The semantic analysis phase is all about doing something
&#8220;meaningful&#8221; with the collected integers. Maybe we should sum them?
Maybe we just want to pass back a nested list structure representing
the parse tree, like this:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>[1 '+' [2 '+' [3 + '4']]]</tt></pre>
</div></div>
<div class="paragraph"><p>given this input:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>1 + 2 + 3 + 4</tt></pre>
</div></div>
<div class="paragraph"><p>Either way, whatever is done, it&#8217;s the job of the semantic analysis
phase to do so. In our example in this article, we produce a sum of
the collected integer series. So, our parser would return: <tt>&nbsp;10 </tt>
for the example input given above.</p></div>
</div>
<div class="sect2">
<h3 id="_what_is_a_em_parser_generator_em">What is a <em>Parser Generator</em>?</h3>
<div class="paragraph"><p>Writing a parser is not easy. Well, it&#8217;s not simple. It&#8217;s fussy. It&#8217;s
messy.  There&#8217;s a lot of repetition and many edge cases and minutia
that bores a good coder to tears. Sure, writing your <strong>first</strong> recursive
descent parser is better than sex, but writing your second one isn&#8217;t.
Writing many is tending towards abstinence. Enough said.</p></div>
<div class="paragraph"><p>So, we (as fun loving coders) want a better alternative.
<a href="http://en.wikipedia.org/wiki/Parser_generator">Parser generators</a>
provide that alternative. They generate parsers; which means they do
all the boring, tedious, repetitive hard-labour and clerical
book-keeping stuff for us. I hope I&#8217;ve painted that with just the
right amount of negative emotion to convince you on a subliminal level
that Parser Generators are a Good Thing&#8482;.</p></div>
</div>
<div class="sect2">
<h3 id="_how_do_they_generate_a_parser_or_what_8217_s_a_em_peg_em">How do they generate a parser? or What&#8217;s a <em>PEG</em>?</h3>
<div class="paragraph"><p>Parser Generators are told <strong>what</strong> to expect (what is valid or invalid)
through a grammar&#8201;&#8212;&#8201;a set of rules describing the allowed constructs
in the language it&#8217;s reading. Defining these rules in a declarative
form is <strong>much</strong> easier, quicker and less error-prone than hand-coding
the equivalent parser.</p></div>
<div class="paragraph"><p>Bryan Ford recently (circa 2004) described a better way[:footnote-1:]
to declare these rules in the form of what he called
<a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar">Parsing
Expression Grammars</a>&#8201;&#8212;&#8201;PEGs.</p></div>
<div class="paragraph"><p>In a nutshell, PEGs describe what is
expected in the input, rather than the (E)BNF approach of describing
what is possible. The difference is subtle but liberating. We&#8217;ll not
go too much into that now&#8201;&#8212;&#8201;except to say: PEGs offer a cleaner way
to describe languages that computers are expected to parse. If you
want to re-program your 13 year old brother, you might not reach for a
PEG parser generator, but as we&#8217;re dabbling here in the confines of
computers and the valley of vim, PEGs will do just fine.</p></div>
<div class="paragraph"><p>A major benefit to PEG parsers is that there is no separate lexical
analysis phase necessary. Because PEG parsers <em>expect</em> to see the
input in a certain way, they can ask for it in those expected chunks.
If it matches, great, move on. If it doesn&#8217;t match, try another
alternative. If all the alternatives fail, then the input doesn&#8217;t
match. Allow for backtracking, and you have all you need to parse
<em>expected</em> input.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="/images/icons/note.png" alt="Note" />
</td>
<td class="content">Vimpeg is <strong>not</strong> a memoising (packrat) parser - not yet, anyway.</td>
</tr></table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A brief overview of the PEG parsing rule syntax:</div>
<div class="ulist"><ul>
<li>
<p>
Terminal symbols are concrete and represent actual strings to be
  matched.
</p>
</li>
<li>
<p>
Non-terminal symbols are names referring to combinations of other
  terminal and/or non-terminal symbols.
</p>
</li>
<li>
<p>
Each rule is of the form:   <tt>A &#8592; e</tt>
</p>
<div class="ulist"><ul>
<li>
<p>
<tt>A</tt> is a non-terminal symbol
</p>
</li>
<li>
<p>
<tt>e</tt> is a parsing expression
</p>
</li>
</ul></div>
</li>
<li>
<p>
Each parsing expression is either: a terminal symbol, a non-terminal
  symbol or the empty string.
</p>
</li>
<li>
<p>
Given the parsing expressions, <tt>e1</tt>, <tt>e2</tt>, and <tt>e3</tt>, a new
  parsing expression can be constructed using the following operators:
</p>
<div class="ulist"><ul>
<li>
<p>
Sequence: <tt> e1 e2 </tt>
</p>
</li>
<li>
<p>
Ordered choice: <tt> e1 / e2 </tt>
</p>
</li>
<li>
<p>
Zero-or-more: <tt> e* </tt>
</p>
</li>
<li>
<p>
One-or-more: <tt>e+ </tt>
</p>
</li>
<li>
<p>
Optional: <tt> e? </tt>
</p>
</li>
<li>
<p>
And-predicate: <tt> &amp;e </tt>
</p>
</li>
<li>
<p>
Not-predicate: <tt> !e </tt>
</p>
</li>
</ul></div>
</li>
</ul></div>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_conceptual_model_of_vimpeg">A Conceptual Model of Vimpeg</h3>
<div class="sect3">
<h4 id="_there_are_three_players_in_the_vimpeg_game">There are three players in the Vimpeg game</h4>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
The Vimpeg Parser Generator (Vim plugin)
</p>
</li>
<li>
<p>
The Language Provider
</p>
</li>
<li>
<p>
The Client
</p>
</li>
</ol></div>
<div class="paragraph"><div class="title">The Vimpeg Parser Generator</div><p>This is a Vim <a href="https://github.com/dahu/Vimpeg">plugin</a> you&#8217;ll need to
install to both create and use Vimpeg based parsers.</p></div>
<div class="paragraph"><div class="title">The Language Provider</div><p>This is someone who creates a parser for a new or existing language or
data-structure. They create the grammar, data-munging callbacks,
utility functions and a public interface into their <em>parser</em>.</p></div>
<div class="paragraph"><div class="title">The Client</div><p>This is someone who wants to <em>use</em> a parser to get some real work
done. Clients can either be Vim end-users or other VimL coders using a
parser as a support layer for even more awesome and complicated
higher-level purposes.</p></div>
</div>
<div class="sect3">
<h4 id="_there_are_five_pieces_to_vimpeg">There are five pieces to Vimpeg</h4>
<div class="paragraph"><p><span class="image">
<img src="content/PegParserGenerator/vimpeg_puzzle.png" alt="content/PegParserGenerator/vimpeg_puzzle.png" />
</span></p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
The Vimpeg library (plugin)
</p>
</li>
<li>
<p>
A PEG Grammar (provider-side)
</p>
</li>
<li>
<p>
Callbacks and utility functions [optional] (provider-side)
</p>
</li>
<li>
<p>
A public interface (provider-side)
</p>
</li>
<li>
<p>
Client code that calls the provider&#8217;s public interface.
   (client-side)
</p>
</li>
</ol></div>
</div>
</div>
<div class="sect2">
<h3 id="_our_parsing_example">Our Parsing Example</h3>
<div class="paragraph"><p>Let&#8217;s return to our parsing example: recognising (and eventually
summing) a sum series of integers.</p></div>
<div class="ulist"><div class="title">Examples of our expected Input:</div><ul>
<li>
<p>
123
</p>
</li>
<li>
<p>
1 + 2 + 3
</p>
</li>
<li>
<p>
12 + 34 + 56 + 78
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">The PEG for a Sum Series of Integers</div>
<div class="content">
<pre><tt>Integer    &lt;-- [0-9]+
Sum        &lt;-- Integer '+' Expression
Expression &lt;-- Sum / Integer</tt></pre>
</div></div>
<div class="paragraph"><p>In the above PEG for matching a Sum Series of Integers, we have:</p></div>
<div class="ulist"><ul>
<li>
<p>
Three non-terminal symbols: <em>Integer</em>, <em>Sum</em> and <em>Expression</em>
</p>
</li>
<li>
<p>
Two terminal symbols: <tt>[0-9]+ </tt>  and  <tt><em>+</em> </tt>
</p>
</li>
<li>
<p>
One use of <strong>Sequence</strong> with the three pieces: <em>Integer</em> '+' <em>Expression</em>
</p>
</li>
<li>
<p>
One use of <strong>Ordered choice</strong>: <em>Sum</em> / <em>Integer</em>
</p>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="/images/icons/note.png" alt="Note" />
</td>
<td class="content">The original (and actual) PEG formalism specifies the
fundamental expression type as a simple string&#8201;&#8212;&#8201;hence the use of <tt>
'+' </tt> to specify a literal <tt> + </tt> character. PEGs also provide
some regular-expression-esque constructs too, like: <tt>[0-9]+ </tt> and
the use of <tt>* </tt>, <tt> + </tt> and <tt>? </tt>.  However, any strings in PEGs
are just that&#8201;&#8212;&#8201;strings, <strong>not</strong> rugular expressions. Vimpeg shuns (at
probable cost) this restriction and allows regular expressions as the
fundamental expression type. So, in Vimpeg, the <tt>[0-9]+ </tt> construct
can more idiomatically be represented using the Vim regex: <tt>\d\+ </tt>.</td>
</tr></table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">The Vimpeg API</div>
<div class="paragraph"><p>The Vimpeg API provides all of the standard PEG constructs:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>peg.e(expression, options)                  (Expression)
peg.and(sequence, options)                  (Sequence)
peg.or(choices, options)                    (Ordered Choice)
peg.maybe_many(expression, options)         (Zero or More)
peg.many(expression, options)               (One or More)
peg.maybe_one(expression, options)          (Optional)
peg.between(expression, min, max, options)
peg.has(expression, options)                (And Predicate)
peg.not_has(expression, options)            (Not Predicate)</tt></pre>
</div></div>
</div></div>
<div class="listingblock">
<div class="title">Defining the Sum Series of Integers PEG in Vimpeg</div>
<div class="content"><div class="highlight"><pre><span class="k">let</span> <span class="k">p</span> <span class="p">=</span> Vimpeg<span class="p">(</span>{<span class="s1">&#39;skip_white&#39;</span>: <span class="m">1</span>}<span class="p">)</span>

<span class="k">call</span> <span class="k">p</span>.<span class="k">e</span><span class="p">(</span><span class="s1">&#39;\d\+&#39;</span><span class="p">,</span> {<span class="s1">&#39;id&#39;</span>: <span class="s1">&#39;integer&#39;</span><span class="p">,</span> <span class="s1">&#39;on_match&#39;</span>: <span class="s1">&#39;Integer&#39;</span>}<span class="p">)</span>
<span class="k">call</span> <span class="k">p</span>.and<span class="p">(</span>[<span class="s1">&#39;integer&#39;</span><span class="p">,</span> <span class="k">p</span>.<span class="k">e</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">),</span> <span class="s1">&#39;expression&#39;</span>]<span class="p">,</span> {<span class="s1">&#39;id&#39;</span>: <span class="s1">&#39;sum&#39;</span>}<span class="p">)</span>
<span class="k">let</span> expression <span class="p">=</span>  <span class="k">p</span>.or<span class="p">(</span>[<span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="s1">&#39;integer&#39;</span>]<span class="p">,</span> {<span class="s1">&#39;id&#39;</span>: <span class="s1">&#39;expression&#39;</span>}<span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>This example demonstrates several aspects of Vimpeg&#8217;s API:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Elements that have been <em>identfied</em> (using an <tt>'id'</tt> attribute)
   can be referred to in other expressions. <em>Sum</em>, <em>Integer</em> and
   <em>Expression</em> are all identified in this case and are all referenced
   by other non-terminals.
</p>
</li>
<li>
<p>
Only root-level elements need to be assigned to a Vim variable. In
   this case, the <em>expression</em> element is considered to be a root
   element&#8201;&#8212;&#8201;we can directly call on that element now to parse a sum
   series of integers.
</p>
</li>
<li>
<p>
Intermediate processing (for evaluations, reductions, lookups,
   whatever) are achieved through callback functions through the
   <tt>'on_match'</tt> attribute.  The <em>Integer</em> rule uses such a callback
   to convert the string representation of the parsed series of digits
   into a single integer value (using the builtin Vim function
   <tt>str2nr()</tt>.) Here is that callback function:
</p>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="k">function</span><span class="p">!</span> Integer<span class="p">(</span>elems<span class="p">)</span>
  <span class="k">return</span> str2nr<span class="p">(</span>a:elems<span class="p">)</span>
<span class="k">endfunction</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="/images/icons/note.png" alt="Note" />
</td>
<td class="content">This is not <strong>strictly</strong> necessary in this example&#8201;&#8212;&#8201;Vim happily
automatically converts string representations of numbers for us in all
the right places for this example to work without the extra overhead
of this callback. It was included in this example only for the purpose
of showing you that it is possible to do so, and how you&#8217;d go about
doing it.</td>
</tr></table>
</div>
</li>
</ol></div>
<div class="listingblock">
<div class="title">The public API interface:</div>
<div class="content"><div class="highlight"><pre><span class="k">function</span><span class="p">!</span> Sum<span class="p">(</span>str<span class="p">)</span>
  <span class="k">let</span> <span class="k">res</span> <span class="p">=</span> g:expression.<span class="k">match</span><span class="p">(</span>a:str<span class="p">)</span>
  <span class="k">if</span> <span class="k">res</span>[<span class="s1">&#39;is_matched&#39;</span>]
    <span class="k">return</span> SumList<span class="p">(</span><span class="k">res</span>[<span class="s1">&#39;value&#39;</span>]<span class="p">)</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="k">res</span>[<span class="s1">&#39;errmsg&#39;</span>]
  <span class="k">endif</span>
<span class="k">endfunction</span>
</pre></div></div></div>
<div class="paragraph"><p>The <tt>res</tt> object holds a lot of information about what was actually
parsed (and an <tt>errmsg</tt>  if parsing failed). The <tt><em>value</em></tt> element
will contain the cumulative result of all the <em>on-match</em> callbacks as
the input was being parsed.</p></div>
<div class="listingblock">
<div class="title">A provider-side utility function:</div>
<div class="content"><div class="highlight"><pre><span class="k">function</span><span class="p">!</span> SumList<span class="p">(</span>s<span class="p">)</span>
  <span class="k">return</span> type<span class="p">(</span>a:s<span class="p">)</span> <span class="p">==</span> type<span class="p">(</span><span class="m">1</span><span class="p">)</span> ? a:s : a:s[<span class="m">0</span>] <span class="p">+</span> SumList<span class="p">(</span>a:s[<span class="m">2</span>]<span class="p">)</span>
<span class="k">endfunction</span>
</pre></div></div></div>
<div class="paragraph"><p>This function performs the second half of <em>semantic analysis</em>, which
is transforming the successfully parsed inout into some desired output
form. In this case, we desire the calculated sum of the series of
integers. This recursive function performs that task on the
intermediate parse-tree that Vimpeg built during the parsing phase.</p></div>
<div class="paragraph"><p>Some might object to including this in <em>semantic analysis</em> and I
concede it&#8217;s probably a bit shabby to do so. Call it what you will&#8230;
this part of the process is all about taking a now known good
intermediate structure and transforming it into a desired output
structure.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_it">Using it</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content"><div class="highlight"><pre>echo Sum<span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>
echo Sum<span class="p">(</span><span class="s1">&#39;1 + 2&#39;</span><span class="p">)</span>
echo Sum<span class="p">(</span><span class="s1">&#39;1 + 2 + 3&#39;</span><span class="p">)</span>
echo Sum<span class="p">(</span><span class="s1">&#39;12 + 34 + 56 + 78&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Not terribly exciting, granted, but hopefully this serves as a
reasonable introduction to the Vimpeg Parser Generator. What can <strong>you</strong>
do with it? I look forward to seeing weird and wonderful creations and
possibilities in Vim now that real parsing tasks are more accessible.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
<a href="http://github.com/dahu/Vimpeg">http://github.com/dahu/Vimpeg</a>
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_what_8217_s_next">What&#8217;s Next?</h2>
<div class="sectionbody">
<div class="paragraph"><p>In the next article I will show an example of sugar-coating the VimL
language to make function declarations both a little easier on the
eyes and fingers as well as adding two long-missing features from
VimL&#8201;&#8212;&#8201;default values in function parameters and inline function
declarations, a la <tt> if &lt;condition&gt; | something | endif </tt>.</p></div>
<div class="paragraph"><p>We <strong>used to</strong> declare these parsing rules in
<a href="http://en.wikipedia.org/wiki/Ebnf">EBNF</a>, intended for a
<a href="http://en.wikipedia.org/wiki/Recursive_descent_parser">recursive
descent parser</a> (or an LL or LALR parser&#8201;&#8212;&#8201;which we will <strong>not</strong> go
into here).  (And before you drown vsdi in comments of "They so still
use that, dude!"&#8201;&#8212;&#8201;I know. <strong>They</strong> do.)</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Version 1.1<br />
Last updated 2012-05-21 00:46:46 PDT
</div>
</div>
</div>
<!-- end article -->
        </div><!-- content -->
      </div><!-- entry -->

    </div><!-- main -->

    <div id="sidebar">
      <h2><a href="/">Home</a></h2>
      
      <ul class='tag_group'>
        <h3><a href="/tag/advanced" rel="tag">advanced</a></h3>
        <li><a href="/PegParserGenerator/PegParserGeneratorIntro/">Peg Parser Generator</a></li>
      </ul><!-- tag_group -->
      
      <ul class='tag_group'>
        <h3><a href="/tag/fun" rel="tag">fun</a></h3>
        <li><a href="/fun/CutSomeCode/">Cut Some Code On The Wild Side</a></li>
      </ul><!-- tag_group -->
      
      <ul class='tag_group'>
        <h3><a href="/tag/genius" rel="tag">genius</a></h3>
        <li><a href="/VimLearningCurve/VimLearningCurve/">Vim Learning Curve</a></li>
      </ul><!-- tag_group -->
      
      <ul class='tag_group'>
        <h3><a href="/tag/learn" rel="tag">learn</a></h3>
        <li><a href="/PegParserGenerator/PegParserGeneratorIntro/">Peg Parser Generator</a></li>
        <li><a href="/VimLearningCurve/VimLearningCurve/">Vim Learning Curve</a></li>
      </ul><!-- tag_group -->
      
      <ul class='tag_group'>
        <h3><a href="/tag/newviml" rel="tag">newviml</a></h3>
        <li><a href="/articles/LongestLine/">The Longest Line</a></li>
      </ul><!-- tag_group -->
      
      <ul class='tag_group'>
        <h3><a href="/tag/test" rel="tag">test</a></h3>
        <li><a href="/about/">About</a></li>
      </ul><!-- tag_group -->
      
      <ul class='tag_group'>
        <h3><a href="/tag/vim" rel="tag">vim</a></h3>
        <li><a href="/about/">About</a></li>
        <li><a href="/PegParserGenerator/PegParserGeneratorIntro/">Peg Parser Generator</a></li>
        <li><a href="/VimLearningCurve/VimLearningCurve/">Vim Learning Curve</a></li>
      </ul><!-- tag_group -->
      
      <ul class='tag_group'>
        <h3><a href="/tag/viml" rel="tag">viml</a></h3>
        <li><a href="/articles/LongestLine/">The Longest Line</a></li>
      </ul><!-- tag_group -->
      
      <ul>
        <h2>nanoc</h2>
        <li><a href="http://nanoc.stoneship.org/docs/">Documentation</a></li>
        <li><a href="http://nanoc.stoneship.org/docs/3-getting-started/">Getting Started</a></li>
        <li><a href="http://groups.google.com/group/nanoc/">Discussion Group</a></li>
        <li><a href="irc://chat.freenode.net/#nanoc">IRC Channel</a></li>
        <li><a href="http://projects.stoneship.org/trac/nanoc/">Wiki</a></li>
      </ul>
    </div><!-- sidebar -->

    <div id="sidebar2">
      <ul class='year_group'>
        <h4>2012</h4>
        <li><a href="/about/">About</a></li>
        <li><a href="/PegParserGenerator/PegParserGeneratorIntro/">Peg Parser Generator</a></li>
        <li><a href="/fun/CutSomeCode/">Cut Some Code On The Wild Side</a></li>
        <li><a href="/VimLearningCurve/VimLearningCurve/">Vim Learning Curve</a></li>
        <li><a href="/articles/LongestLine/">The Longest Line</a></li>
      </ul><!-- year_group -->
    </div><!-- sidebar2 -->

  </body>
</html>

