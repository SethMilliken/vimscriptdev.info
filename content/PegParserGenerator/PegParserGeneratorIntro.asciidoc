Introducing Vimpeg -- A PEG Parser Generator for Vim
====================================================
Barry Arthur
v1.1, October 10, 2011

image:content/PegParserGenerator/vimpeg.png[]

Parsing
-------

Feel free to skip to the next section if you're comfortable with the
following concepts:

* parsing
* pasrer generators
* (E)BNF and PEGs

Let's begin by defining some terms:

(Let's all assume we know what http://www.vim.org[Vim] is.)

What is 'Parsing'?
~~~~~~~~~~~~~~~~~~

http://en.wikipedia.org/wiki/Parsing[Parsing] is making sense of
something.  When we want a computer to understand something we've
written down for it to do, it needs to 'parse' that writing.  Without
going into too much detail yet, let's consider a sentence uttered at
one time or another by your parental unit: "Take the rubbish out!".
When you (eventually -- after you unplug your iPod, put down your PS3
controller, pocket your smart-phone and wipe the disdain off your
face) parse this sentence, your brain goes through two processes:

.firstly (syntax recognition):
* it scans the words to make sure they're legitimate:
** they're in a language you know
** they're all valid words, and
** they're all in the right order

.and secondly (semantic analysis):
* it filters out the 'meaning' and presents that to a higher actor
  for further deliberation

In this case, the parser would extract the verb phrase 'take out' and
the noun 'rubbish'. Your higher self (sarcasm aside) *knows* where
this magic 'out' place is. We'll come back to these two processes
('syntax recognition' and 'semantic analysis') later.

What is a 'Parser Generator'?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Writing a parser is not easy. Well, it's not simple. It's fussy. It's
messy.  There's a lot of repetition and many edge cases and minutia
that bores a good coder to tears. Sure, writing your *first* recursive
descent parser is better than sex, but writing your second one isn't.
Writing many is tending towards abstinence. Enough said.

So, we (as
fun loving coders) want a better alternative.
http://en.wikipedia.org/wiki/Parser_generator[Parser generators]
provide that alternative. They generate parsers; which means they do
all the boring, tedious, repetitive hard-labour and clerical
book-keeping stuff for us. I hope I've painted that with just the
right amount of negative emotion to convince you on a subliminal level
that Parser Generators are a Good Thing(TM).

How do they generate a parser? or What's a 'PEG'?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Parser Generators are told *what* to expect (what is valid or invalid)
through a grammar -- a set of rules describing the allowed constructs
in the language it's reading. Defining these rules in a declarative
form is *much* easier, quicker and less error-prone than hand-coding
the equivalent parser.

Without lingering in the land of ye olde parsing approaches for too
long, we *used to* declare these parsing rules in
http://en.wikipedia.org/wiki/Ebnf[EBNF], intended for a
http://en.wikipedia.org/wiki/Recursive_descent_parser[recursive
descent parser] (or an LL or LALR parser -- which we will *not* go
into here).  (And before you drown vsdi in comments of "They so still
use that, dude!" -- I know. *They* do.) Bryan Ford recently (circa
2004) described a better way to declare these rules in the form of
what he called
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parsing
Expression Grammars] -- PEGs.

In a nutshell, PEGs describe what is
expected in the input, rather than the (E)BNF approach of describing
what is possible. The difference is subtle but liberating. We'll not
go too much into that now -- except to say: PEGs offer a cleaner way
to describe languages that computers are expected to parse. If you
want to re-program your 13 year old brother, you might not reach for a
PEG parser generator, but as we're dabbling here in the confines of
computers and the valley of vim, PEGs will do just fine.

A major benefit to PEG parsers is that there is no separate lexical
analysis phase necessary. Because PEG parsers 'expect' to see the
input in a certain way, they can ask for it in those expected chunks.
If it matches, great, move on. If it doesn't match, try another
alternative. If all the alternatives fail, then the input doesn't
match. Allow for backtracking, and you have all you need to parse
'expected' input.

NOTE: Vimpeg is *not* a memoising (packrat) parser - not yet, anyway.

Vimpeg
------

Vimpeg is a Parser Generator which uses the newer Parsing Expression
Grammar formalism to specify the parse rules.

.What would I use Vimpeg for?

* You've come to that paralysing sinkhole in your Vimming when you've
  said to youself, "Damn... I wish Vim had a parser."
* You've asked for something on #vim and the reply is "you can't do
  that because Vim doesn't have a parser."
* You're up to your neck in wrecklessly recursive regexes.

.Some ideas:

* An expression calculator (the beginnings of which we explore here.)
* Expanding tokens in typed text (think: snippets, abbrevs, maps.)
* Semantic analysis of code -- for refactoring, reindenting (but sadly
  not syntax highlighting yet.)
* C Code bifurcation based on #define values -- want to see what the C
  code would look like with ++#define DEBUG++ disabled?
* Coffeescript for Vim -- sugar-coating some of the uglies in VimL --
  this example will be presented in a subsequent Vimpeg article.

In fact, most of these ideas have been explored in part inside the
++examples/++ directory of the https://github.com/dahu/Vimpeg[Vimpeg]
plugin.

A Conceptual Model
~~~~~~~~~~~~~~~~~~

There are three players in the Vimpeg game
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

1. The Vimpeg Parser Generator (Vim plugin)
2. The Language Provider
3. The Client

.The Vimpeg Parser Generator

This is a Vim https://github.com/dahu/Vimpeg[plugin] you'll need to
install to both create and use Vimpeg based parsers.

.The Language Provider

This is someone who creates a parser for a new or existing language or
data-structure. They create the grammar, data-munging callbacks,
utility functions and a public interface into their 'parser'.

.The Client

This is someone who wants to 'use' a parser to get some real work
done. Clients can either be Vim end-users or other VimL coders using a
parser as a support layer for even more awesome and complicated
higher-level purposes.

There are five pieces to Vimpeg
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

image:content/PegParserGenerator/vimpeg_puzzle.png[]

1. The Vimpeg library (plugin)
2. A PEG Grammar (provider-side)
3. Callbacks and utility functions [optional] (provider-side)
4. A public interface (provider-side)
5. Client code that calls the provider's public interface.
   (client-side)

A Parsing Example
~~~~~~~~~~~~~~~~~

Most beginner Parsing tutorials show you how to scan for numbers or at
best, the addition of two numbers. Who am I to blow against the wind?
Let's do that. Let's create a parser that expects a series of integers
connected with ++ + ++ operators.

.Examples of our expected Input:

* 123
* 1 + 2 + 3
* 12 + 34 + 56 + 78

.A brief overview of the PEG parsing rule syntax:
*********************************************************************

* Terminal symbols are concrete and represent actual strings to be
  matched.
* Non-terminal symbols are names referring to combinations of other
  terminal and/or non-terminal symbols.

* Each rule is of the form:   ++A <- e++
** ++A++ is a non-terminal symbol
** ++e++ is a parsing expression

* Each parsing expression is either: a terminal symbol, a non-terminal
  symbol or the empty string.

* Given the parsing expressions, ++e1++, ++e2++, and ++e3++, a new
  parsing expression can be constructed using the following operators:
** Sequence: ++ e1 e2 ++
** Ordered choice: ++ e1 / e2 ++
** Zero-or-more: ++ e* ++
** One-or-more: ++e+ ++
** Optional: ++ e? ++
** And-predicate: ++ &e ++
** Not-predicate:Â ++ !e ++

*********************************************************************

.The PEG for a Sum Series of Integers
---------------------------------------------------------------------
Integer    <-- [0-9]+
Sum        <-- Integer '+' Expression
Expression <-- Sum / Integer
---------------------------------------------------------------------

In the above PEG for matching a Sum Series of Integers, we have:

* Three non-terminal symbols: 'Integer', 'Sum' and 'Expression'
* Two terminal symbols: ++[0-9]+ ++  and  ++'+' ++
* One use of *Sequence* with the three pieces: 'Integer' \'+' 'Expression'
* One use of *Ordered choice*: 'Sum' / 'Integer'

NOTE: The original (and actual) PEG formalism specifies the
fundamental expression type as a simple string -- hence the use of ++ \'\+' ++ to
specify a literal ++ + ++ character. PEGs also provide some
regular-expression-esque constructs too, like: ++[0-9]+ ++ and the use of ++*
++, ++ + ++ and ++? ++.  However, any strings in PEGs are just that -- strings,
*not* rugular expressions. Vimpeg shuns (at probable cost) this restriction and
allows regular expressions as the fundamental expression type. So, in Vimpeg,
the ++[0-9]+ ++ construct can more idiomatically be represented using the Vim
regex: ++\d\+ ++.

.The Vimpeg API
*********************************************************************
The Vimpeg API provides all of the standard PEG constructs:

   peg.e(expression, options)           (Expression)
   peg.and(sequence, options)           (Sequence)
   peg.or(choices, options)             (Ordered Choice)
   peg.maybe_many(expression, options)  (Zero or More)
   peg.many(expression, options)        (One or More)
   peg.maybe_one(expression, options)   (Optional)
   peg.between(expression, min, max, options)
   peg.has(expression, options)         (And Predicate)
   peg.not_has(expression, options)     (Not Predicate)

*********************************************************************

.Defining the Sum Series of Integers PEG in Vimpeg
[source,vim]
---------------------------------------------------------------------
let p = Vimpeg({'skip_white': 1})

call p.e('\d\+', {'id': 'integer', 'on_match': 'Integer'})
call p.and(['integer', p.e('+'), 'expression'], {'id': 'sum'})
let expression =  p.or(['sum', 'integer'], {'id': 'expression'})
---------------------------------------------------------------------

This example demonstrates several aspects of Vimpeg's API:

1. Elements that have been 'identfied' (using an ++\'id'++ attribute)
   can be referred to in other expressions. 'Sum', 'Integer' and
   'Expression' are all identified in this case and are all referenced
   by other non-terminals.

2. Only root-level elements need to be assigned to a Vim variable. In
   this case, the 'expression' element is considered to be a root
   element -- we can directly call on that element now to parse a sum
   series of integers.

3. Intermediate processing (for evaluations, reductions, lookups,
   whatever) are achieved through callback functions through the
   ++\'on_match'++ attribute.  The 'Integer' rule uses such a callback
   to convert the string representation of the parsed series of digits
   into a single integer value (using the builtin Vim function
   ++str2nr()++.) Here is that callback function:
+
[source,vim]
---------------------------------------------------------------------
function! Integer(elems)
  return str2nr(a:elems)
endfunction
---------------------------------------------------------------------
+
NOTE: This is not *strictly* necessary in this example -- Vim happily
automatically converts string representations of numbers for us in all
the right places for this example to work without the extra overhead
of this callback. It was included in this example only for the purpose
of showing you that it is possible to do so, and how you'd go about
doing it.

.The public API interface:
[source,vim]
---------------------------------------------------------------------
function! Sum(str)
  let res = g:expression.match(a:str)
  if res['is_matched']
    return SumList(res['value'])
  else
    return res['errmsg']
  endif
endfunction
---------------------------------------------------------------------

The ++res++ object holds a lot of information about what was actually
parsed (and an ++errmsg++  if parsing failed). The ++'value'++ element
will contain the cumulative result of all the 'on-match' callbacks as
the input was being parsed.

.A provider-side utility function:
[source,vim]
---------------------------------------------------------------------
function! SumList(s)
  return type(a:s) == type(1) ? a:s : a:s[0] + SumList(a:s[2])
endfunction
---------------------------------------------------------------------

As mentioned earlier, this function is not strictly necessary because
Vim will automatically cast our string representation of an integer
('12') into the corresponding actual integer (12) for us in the right
places. This function is included here mainly for completeness to show
how, in Vimpeg, callback functions can be used to modify values in the
middle of parsing.

Using it
--------

[source,vim]
---------------------------------------------------------------------
echo Sum('123')
echo Sum('1 + 2')
echo Sum('1 + 2 + 3')
echo Sum('12 + 34 + 56 + 78')
---------------------------------------------------------------------

Not terribly exciting, granted, but hopefully this serves as a
reasonable introduction to the Vimpeg Parser Generator. What can *you*
do with it? I look forward to seeing weird and wonderful creations and
possibilities in Vim now that real parsing tasks are more accessible.

Resources
---------

* http://github.com/dahu/Vimpeg[]

What's Next?
------------

In the next article I will show an example of sugar-coating the VimL
language to make function declarations both a little easier on the
eyes and fingers as well as adding two long-missing features from
VimL -- default values in function parameters and inline function
declarations, a la ++ if <condition> | something | endif ++.
